import{_ as a,c as s,o as i,U as e}from"./chunks/framework.NOjL19Y0.js";const t="/assets/image-20240516165417923.b8_hxoDP.png",p="/assets/image-20240516165755972.YceO91DM.png",b=JSON.parse('{"title":"patch-package","description":"","frontmatter":{},"headers":[],"relativePath":"docs/notes/patch-package.md","filePath":"docs/notes/patch-package.md","lastUpdated":1727143404000}'),n={name:"docs/notes/patch-package.md"},l=e('<h1 id="patch-package" tabindex="-1">patch-package <a class="header-anchor" href="#patch-package" aria-label="Permalink to &quot;patch-package&quot;">​</a></h1><h2 id="一、背景" tabindex="-1">一、背景 <a class="header-anchor" href="#一、背景" aria-label="Permalink to &quot;一、背景&quot;">​</a></h2><p>起初是发现有一天<code>npm install</code> 之后项目突然跑不起来了，就开始了排查之旅。排查到最后发现<code>taro-ui</code>按需引入<code>toast</code>样式文件后，文件对比之前突然多了一行代码。修改<code>node_modules</code>中源代码后项目就可以正常启动了。</p><p>随后我就跑去<code>github</code>给<code>taro-ui</code>提issue，第二天被告知维护者已经给<code>taro</code>提了pr，但是对于我这个版本没有效果（这里后来没问出原因），他说可以用<code>patch</code>的方式去先暂时把源码改掉。</p><p>这时，我才发现一个新工具 <code>patch-package</code></p><h4 id="作用" tabindex="-1">作用 <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;作用&quot;">​</a></h4><blockquote><p>lets app authors instantly make and keep fixes to npm dependencies. It&#39;s a vital band-aid for those of us living on the bleeding edge.</p></blockquote><p>这是npm官网上对patch-package的说明，意思就是<em>允许应用程序作者立即对NPM依赖项进行修复。对于前端来说，这是一个至关重要的补丁。</em> 也就是说可以让大家对node_modules进行立即更改。</p><h2 id="二、使用" tabindex="-1">二、使用 <a class="header-anchor" href="#二、使用" aria-label="Permalink to &quot;二、使用&quot;">​</a></h2><h4 id="_1-安装" tabindex="-1">1. 安装 <a class="header-anchor" href="#_1-安装" aria-label="Permalink to &quot;1. 安装&quot;">​</a></h4><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> patch-package</span></span></code></pre></div><p>如果你不需要在生产中运行</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> patch-package</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --save-dev</span></span></code></pre></div><p>yarn、pnpm、docker安装命令可查看其 <a href="https://link.zhihu.com/?target=https%3A//github.com/ds300/patch-package" target="_blank" rel="noreferrer">git官网。</a></p><h4 id="_2-修改npm包" tabindex="-1">2. 修改npm包 <a class="header-anchor" href="#_2-修改npm包" aria-label="Permalink to &quot;2. 修改npm包&quot;">​</a></h4><p>更改node_modules 文件夹中要修改依赖包的文件</p><h4 id="_3-生成补丁文件" tabindex="-1">3. 生成补丁文件 <a class="header-anchor" href="#_3-生成补丁文件" aria-label="Permalink to &quot;3. 生成补丁文件&quot;">​</a></h4><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npx</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> patch-package</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> package-name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">修改包名</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>会自动在项目中生成一个patches文件夹，并放置了修改文件的patch文件</p><p><img src="'+t+`" alt="image-20240516165417923"></p><p>内容如下</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>diff --git a/node_modules/taro-ui/dist/style/components/toast.scss b/node_modules/taro-ui/dist/style/components/toast.scss</span></span>
<span class="line"><span>index f53d1ec..6163d14 100644</span></span>
<span class="line"><span>--- a/node_modules/taro-ui/dist/style/components/toast.scss</span></span>
<span class="line"><span>+++ b/node_modules/taro-ui/dist/style/components/toast.scss</span></span>
<span class="line"><span>@@ -1,4 +1,3 @@</span></span>
<span class="line"><span>-@use &quot;sass:math&quot;;</span></span>
<span class="line"><span> @import &#39;../variables/default.scss&#39;;</span></span>
<span class="line"><span> @import &#39;../mixins/index.scss&#39;;</span></span></code></pre></div><h4 id="_4-添加自动执行命令" tabindex="-1">4. 添加自动执行命令 <a class="header-anchor" href="#_4-添加自动执行命令" aria-label="Permalink to &quot;4. 添加自动执行命令&quot;">​</a></h4><p>In package.json</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;scripts&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">   ...</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;postinstall&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;patch-package&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span></code></pre></div><h4 id="_5-重新安装node-modules依赖" tabindex="-1">5. 重新安装node_modules依赖 <a class="header-anchor" href="#_5-重新安装node-modules依赖" aria-label="Permalink to &quot;5. 重新安装node_modules依赖&quot;">​</a></h4><p>至此已完成，重新删除node_modules后执行 <code>npm install</code> 会发现代码已经是修改过后的。</p><p><img src="`+p+`" alt="image-20240516165755972"></p><h4 id="_6-patch文件是什么" tabindex="-1">6.patch文件是什么? <a class="header-anchor" href="#_6-patch文件是什么" aria-label="Permalink to &quot;6.patch文件是什么?&quot;">​</a></h4><p>其实就是一些<code>git diff</code>记录描述。</p><p><strong>原理</strong>: patch-package会将当前 node_modules下的源码与原始源码进行 git diff，并在项目根目录下生成一个<code>patch</code>补丁文件。</p><h4 id="_7-patch-package-的好处" tabindex="-1">7.patch-package 的好处 <a class="header-anchor" href="#_7-patch-package-的好处" aria-label="Permalink to &quot;7.patch-package 的好处&quot;">​</a></h4><h5 id="版本预检" tabindex="-1">版本预检 <a class="header-anchor" href="#版本预检" aria-label="Permalink to &quot;版本预检&quot;">​</a></h5><p>当依赖项发生更改时，会以红色大写字母通知，需要检查所做修复是否仍然有效。npx patch-package 会直接报错<strong>ERROR</strong> Failed to apply patch for package xxxx at path，通过提示可以更方便定位问题。</p><h5 id="节省空间" tabindex="-1">节省空间 <a class="header-anchor" href="#节省空间" aria-label="Permalink to &quot;节省空间&quot;">​</a></h5><p>无需拷贝一份源码，使用git diff来记录补丁更节省空间，安全又便捷。</p><h5 id="可审查" tabindex="-1">可审查 <a class="header-anchor" href="#可审查" aria-label="Permalink to &quot;可审查&quot;">​</a></h5><p>补丁可以作为正常审查过程的一部分进行审查。</p><h2 id="三、其他方法" tabindex="-1">三、其他方法 <a class="header-anchor" href="#三、其他方法" aria-label="Permalink to &quot;三、其他方法&quot;">​</a></h2><ol><li><p>给第三方库提issue等待维护人员修复</p></li><li><p>给依赖包提pr自定修复并等待发布</p></li><li><p>整体copy项目</p><ol><li>直接引用法 （直接copy依赖包的源码，本地引用，不再通过npm包方式引用）</li><li>发布私库法（适合多项目中使用同一个依赖包的场景，可以把修改后的源码发布到私有的仓库上 ）</li></ol></li><li><p>修改引用法</p><p>配置一个webpack alias别名，如&#39;原始文件的引用路径&#39;: &#39;修改后文件的引用路径&#39;，使得最终修改后的文件被引用，如：</p></li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  alias</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &#39;pdfjs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: path.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(__dirname, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./patched/pdfjs/*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以上方法均有弊端：</p><p>前两种修复周期很长且依赖第三方，修复时间不定，不适合解决当前问题。</p><p>后几种方法都比较复杂，并且会导致项目臃肿，更容易忘记自己修改了源码的哪个部分，而且更新麻烦，每次都需要手动去更新代码，无法与插件同步更新。</p>`,44),h=[l];function o(c,d,r,k,g,u){return i(),s("div",null,h)}const E=a(n,[["render",o]]);export{b as __pageData,E as default};
